We are now ready to integrate real circuit simulation into the sandbox app using avr8js. Do not change the visual UI ‚Äî layout, DOM structure, styles, and component hierarchy must remain exactly as they are. However, you are allowed to completely rewrite the logic behind any existing buttons, pins, or component behavior to support simulation.

‚∏ª

üß† Planning Instructions (Before Writing Code):

Step 1: Analyze the UI
	‚Ä¢	Identify where components like buttons, wires, pins, and microcontrollers (e.g., ATmega328P or HeroBoard) are currently defined in code.
	‚Ä¢	Locate where the ‚ÄúRun‚Äù or ‚ÄúSimulate‚Äù actions are triggered in the UI ‚Äî even if they do nothing today.

Step 2: Simulation Engine Planning
	‚Ä¢	Confirm which board/chip we‚Äôll simulate with avr8js ‚Äî ideally ATmega328P for compatibility with existing Arduino-based kits.
	‚Ä¢	Plan a data model to translate:
	‚Ä¢	UI components (e.g. LED, button, resistor)
	‚Ä¢	Wiring (start pin, end pin)
	‚Ä¢	into a virtual circuit state that avr8js can work with.

Step 3: Execution Flow
	‚Ä¢	On simulation start, initialize a virtual CPU using AVRRunner.
	‚Ä¢	Load example or user-written firmware (e.g., hex or .ino sketch).
	‚Ä¢	Route pin state updates to connected UI elements (e.g., LED turning on updates UI class).
	‚Ä¢	Allow virtual pins to respond to UI interaction (e.g., clicking a button injects signal).
	‚Ä¢	Simulate the timing loop with AVRTimer or setInterval() using cpu.execute() and timer.tick().

Step 4: Communication
	‚Ä¢	Wire-to-wire logic should act as a signal bus. If Pin 13 is HIGH, and it‚Äôs wired to an LED anode, update the UI LED state.
	‚Ä¢	Use virtual ports in avr8js to map state changes to your component model.

‚∏ª

Constraints:
	‚Ä¢	You may rewrite component behavior or event handlers to support simulation.
	‚Ä¢	You may not alter or remove any existing visual elements or layout structure.
	‚Ä¢	Use console logging extensively for the initial integration so we can verify pin state, timing, and simulation flow.

‚∏ª

Success Criteria:
	‚Ä¢	The simulation should start by clicking the existing Run/Simulate button.
	‚Ä¢	A loaded firmware sketch (hex or compiled code) should drive the ATmega chip and visibly affect pins.
	‚Ä¢	Changes in the virtual circuit (LEDs on/off, button press, etc.) should be reflected in the UI using the current component visuals.
	‚Ä¢	All pin behaviors should remain consistent with real-world microcontroller simulation.

‚∏ª

Let me know when the plan is fully mapped and only then begin writing code. I want a working simulation connected to our static UI ‚Äî not a UI redesign.